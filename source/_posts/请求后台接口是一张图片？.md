---
title: 请求后台接口是一张图片？
date: 2018-04-19 17:03:52
tags: js
---

需求是这样的，每个人打开页面对应自己的图片二维码没然后这张图还得全屏充满(好吧这不是重点)  
然后，后台给接口地址，传参数，发接口，收到的data竟然是一串乱码，一看以JFIF开头（？？？二进制！），这请求的不就是一张图片么，后台你在逗我？  
原以为我请求你接口，你返回一个url，我放上就好了。。。后台说这样占用服务器资源，要不帮你转成base64吧  

**base64！！！**一张充满的背景图，还是算了吧，有点大

### 解决：
<!--more-->
几个关键点
* responseType  

|      设置值     |      返回类型     |
|-----------------|:-----------------:|
|        ""       | DOMString(default)|
|  "arraybuffer"  |     ArrayBuffer   |
|     "blob"      |   Blob(二进制流)  |
|    "document"   |      Document     |
|      "json"     |        JSON       |
|      "text"     |      DOMString    |
其中**blob**就是我们需要的responseType
* createObjectURL  
URL.createObjectURL()静态方法会创建一个DOMString，其中包含一个表示参数中给出的对象的URL。这个URL的生命周期和创建它的窗口中的document绑定。这个新的URL对象表示指定的 File 对象或 Blob 对象。
```javascript
objectURL = URL.createObjectURL(blob);
```
* revokeObjectURL  
在每次调用 createObjectURL()方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL对象时，每个对象必须通过调用URL.revokeObjectURL() 方法来释放。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。
```javacript
window.URL.revokeObjectURL(objectURL);
```
createObjectURL()方法，是接收一个文件的引用返回一个URL对象。这是通知浏览器来创建和管理一个URL来加载文件。 revokeObjectURL()方法，则是销毁创建的URL，有效果释放内存。当然，所有的URL对象将在浏览器重新载入时全部被销毁，也有助于释放它们占用的内存。

URL 变量是原生浏览器对象的一个引用，假设浏览器支持URL对象，URL通过file创建一个对象赋值给imageUrl变量。 元素的onload 事件触发后将销毁URL 对象(一分钟内)，接着，给src属性赋值后将追加到页面上（你也可以使用一个页面上已有的元素的）。

要及时销毁URL对象，除非你有多个file需要使用，所以图片加载完销毁它是最佳内存释放时机。
```
var xmlhttp;
xmlhttp=new XMLHttpRequest();
xmlhttp.open("GET","http://localhost:8000/test.jpg",true);
xmlhttp.responseType = "blob";
xmlhttp.onload = function(){
    if (this.status == 200) {
        var blob = this.response;
        var img = document.createElement("img");
        img.onload = function(e) {
            window.URL.revokeObjectURL(img.src); 
        };
        img.src = window.URL.createObjectURL(blob);
        document.body.appendChild(img); 
    }
}
xmlhttp.send();
```
如果你已经有img标签，可以不用`var img = document.createElement("img");`直接指定src即可