---
title: 隐式强制类型转换总结
date: 2018-08-24 11:30:14
tags: js
---
首先了解一下[[toPrimitive]]和DefaultValue
**[[toPrimitive]]**：  
抽象操作 ToPrimitive（参见 ES5 规范 9.1 节）会首先检查该值是否有 valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString()的返回值（如果存在）来进行强制类型转换。（如果valueOf返回来的不是基本类型值，则调用toString()）来取得DefaultValue
<!--more-->
+ `+符号`
  + 一元运算符
    `1+1`
  + 字符串拼接
    `''+1`
    规则：
    > 如果某个操作数是字符串或者能通过`[[toPrimitive]]`转换为字符串的话，+将进行拼接操作  
    > 应用布尔值时，先转换为Number，在执行+
  +  类型转换  `+'1' === 1`
+ `-, *, /`
  一律Number对待，转不成Number不行就NaN
+ `==`
  类型不同时，把两边最终都转为Number进行比较：`[]==false // true`，其中`[](toString())` => `''` (`toNumber`) => 0。false => 0
+ `>` `<`
  双方调用[[toPrimitive]]，如果出现非字符串，就将双方都转为Number
  + `[] < 1 //true`
  + `[]<{} //true`，双方调用valueOf(),toString() => `"[object Array]" < "[object Object]"`，字符串相比，`'A'`小于`'D'`所以为true

懂了这些之后来看一个
```javascript
var a = new String('abc')
var b = new String('abc')
a == b //?
a < b //?
a > b //?
a >= b //?
a >= b //?
```
1. 首先第一个，两个都是object引用类型，自然不相等，所以为false
2. `<`将两边都valueOf，得到原始值`"abc"`，
  `"abc" < "abc"`，自然是false
3. 同上，false
4.  `>=`和`<=`并不是我们传统理解的大于等于和小于等于，他在计算机内部其实是**不小于`a>=b => !(a<b)`**和**不大于`a<=b => !(a>b)`**，知道这个以后就很好理解了，上面大于小于都是false，这个自然是true了
5. 同上

正如《你不知道的javascript(中卷)》中所说
> 关于强制类型转换是一个设计上的缺陷还是有用的特性，这一争论从JavaScript 诞生之日起就开始了
> 对于不懂的地方我们应该迎难而上，知其然并且知其所以然，不会因为种种传言和挫折就退避三舍。

> 强制类型转换常常为人诟病，但实际上很多时候它们是非常有用的。作为有使命感的JavaScript 开发人员，我们有必要深入了解强制类型转换，这样就能取其精华，去其糟粕

我的想法跟他如出一辙，正是因为这些特性，js才变得如此迷人。